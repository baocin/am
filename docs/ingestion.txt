package main

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"

	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"
	"github.com/nats-io/nats.go"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/trace"
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

type DataPayload struct {
	DeviceID  string `json:"device_id"`
	Timestamp string `json:"timestamp"`
	Data      string `json:"data"`
	Format    string `json:"format"`
	TraceID   string `json:"trace_id"`
}

type Metadata struct {
	DeviceID  string `json:"device_id"`
	Timestamp string `json:"timestamp"`
	FilePath  string `json:"file_path"`
	Format    string `json:"format"`
	TraceID   string `json:"trace_id"`
}

var tracer = otel.Tracer("ingestion-service")

func main() {
	nc, err := nats.Connect("nats://loom-nats:4222")
	if err != nil {
		log.Fatal("Failed to connect to NATS:", err)
	}
	defer nc.Close()

	r := mux.NewRouter()
	r.HandleFunc("/upload", handleUpload(nc)).Methods("POST")
	r.HandleFunc("/stream/{device_id}", handleStream(nc))

	log.Println("Starting ingestion service on :8000")
	log.Fatal(http.ListenAndServe(":8000", r))
}

func handleUpload(nc *nats.Conn) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := tracer.Start(r.Context(), "handleUpload")
		defer span.End()

		var payload DataPayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid payload", http.StatusBadRequest)
			return
		}

		filePath := filepath.Join("/data", payload.DeviceID, payload.Timestamp+"."+payload.Format)
		if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
			http.Error(w, "Failed to create directory", http.StatusInternalServerError)
			return
		}
		if err := ioutil.WriteFile(filePath, []byte(payload.Data), 0644); err != nil {
			http.Error(w, "Failed to write file", http.StatusInternalServerError)
			return
		}

		metadata := Metadata{
			DeviceID:  payload.DeviceID,
			Timestamp: payload.Timestamp,
			FilePath:  filePath,
			Format:    payload.Format,
			TraceID:   span.SpanContext().TraceID().String(),
		}
		data, err := json.Marshal(metadata)
		if err != nil {
			http.Error(w, "Failed to serialize metadata", http.StatusInternalServerError)
			return
		}

		subject := "user." + payload.DeviceID + ".data.raw"
		if err := nc.Publish(subject, data); err != nil {
			http.Error(w, "Failed to publish to NATS", http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
	}
}

func handleStream(nc *nats.Conn) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, span := tracer.Start(r.Context(), "handleStream")
		defer span.End()

		vars := mux.Vars(r)
		deviceID := vars["device_id"]

		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			log.Println("WebSocket upgrade failed:", err)
			return
		}
		defer conn.Close()

		for {
			var payload DataPayload
			if err := conn.ReadJSON(&payload); err != nil {
				log.Println("WebSocket read error:", err)
				break
			}

			payload.DeviceID = deviceID
			filePath := filepath.Join("/data", deviceID, payload.Timestamp+"."+payload.Format)
			if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
				log.Println("Failed to create directory:", err)
				continue
			}
			if err := ioutil.WriteFile(filePath, []byte(payload.Data), 0644); err != nil {
				log.Println("Failed to write file:", err)
				continue
			}

			metadata := Metadata{
				DeviceID:  deviceID,
				Timestamp: payload.Timestamp,
				FilePath:  filePath,
				Format:    payload.Format,
				TraceID:   span.SpanContext().TraceID().String(),
			}
			data, err := json.Marshal(metadata)
			if err != nil {
				log.Println("Failed to serialize metadata:", err)
				continue
			}

			subject := "user." + deviceID + ".data.raw"
			if err := nc.Publish(subject, data); err != nil {
				log.Println("Failed to publish to NATS:", err)
			}
		}
	}
}